-- =====================================================
-- MASOMO HUB CONNECT: NEW CLASS SYSTEM
-- Community-Driven Class Creation & Management
-- =====================================================

-- =====================================================
-- PART 1: COUNTRIES, UNIVERSITIES, COURSES TABLES
-- =====================================================

-- Countries Table
CREATE TABLE IF NOT EXISTS public.countries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,
  code TEXT UNIQUE, -- ISO country code (e.g., 'KE', 'US', 'UK')
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_countries_name ON public.countries(name);

-- Universities Table
CREATE TABLE IF NOT EXISTS public.universities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  country_id UUID NOT NULL REFERENCES public.countries(id) ON DELETE CASCADE,
  description TEXT,
  website TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(name, country_id) -- Same university name can exist in different countries
);

CREATE INDEX IF NOT EXISTS idx_universities_country ON public.universities(country_id);
CREATE INDEX IF NOT EXISTS idx_universities_name ON public.universities(name);

-- Courses Table
CREATE TABLE IF NOT EXISTS public.courses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  university_id UUID NOT NULL REFERENCES public.universities(id) ON DELETE CASCADE,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(name, university_id) -- Same course name can exist in different universities
);

CREATE INDEX IF NOT EXISTS idx_courses_university ON public.courses(university_id);
CREATE INDEX IF NOT EXISTS idx_courses_name ON public.courses(name);

-- =====================================================
-- PART 2: UPDATE PROFILES TABLE
-- =====================================================

-- Add new columns to profiles table
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS country_id UUID REFERENCES public.countries(id),
ADD COLUMN IF NOT EXISTS university_id UUID REFERENCES public.universities(id),
ADD COLUMN IF NOT EXISTS course_id UUID REFERENCES public.courses(id),
ADD COLUMN IF NOT EXISTS year TEXT, -- Flexible: "1", "2", "3rd Year", "Final Year", etc.
ADD COLUMN IF NOT EXISTS semester TEXT, -- Flexible: "Fall", "Spring", "1", "2", etc.
ADD COLUMN IF NOT EXISTS student_status TEXT DEFAULT 'student' CHECK (student_status IN ('student', 'graduated', 'alumni'));

CREATE INDEX IF NOT EXISTS idx_profiles_country ON public.profiles(country_id);
CREATE INDEX IF NOT EXISTS idx_profiles_university ON public.profiles(university_id);
CREATE INDEX IF NOT EXISTS idx_profiles_course ON public.profiles(course_id);
CREATE INDEX IF NOT EXISTS idx_profiles_student_status ON public.profiles(student_status);

-- =====================================================
-- PART 3: CLASSES TABLE (NEW SYSTEM)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.classes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  creator_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  share_code TEXT UNIQUE, -- Unique shareable code (auto-generated by trigger)
  is_searchable BOOLEAN DEFAULT TRUE, -- Can be found in global search
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_classes_creator ON public.classes(creator_id);
CREATE INDEX IF NOT EXISTS idx_classes_share_code ON public.classes(share_code);
CREATE INDEX IF NOT EXISTS idx_classes_searchable ON public.classes(is_searchable);
CREATE INDEX IF NOT EXISTS idx_classes_name ON public.classes(name);

-- =====================================================
-- PART 4: CLASS UNITS TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS public.class_units (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  class_id UUID NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  unit_order INTEGER DEFAULT 0, -- For ordering units
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_class_units_class ON public.class_units(class_id);
CREATE INDEX IF NOT EXISTS idx_class_units_order ON public.class_units(class_id, unit_order);

-- =====================================================
-- PART 5: CLASS MEMBERS TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS public.class_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  class_id UUID NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT DEFAULT 'member' CHECK (role IN ('creator', 'member')),
  joined_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(class_id, user_id) -- A user can only be a member once per class
);

CREATE INDEX IF NOT EXISTS idx_class_members_class ON public.class_members(class_id);
CREATE INDEX IF NOT EXISTS idx_class_members_user ON public.class_members(user_id);
CREATE INDEX IF NOT EXISTS idx_class_members_role ON public.class_members(class_id, role);
CREATE INDEX IF NOT EXISTS idx_class_members_joined ON public.class_members(class_id, joined_at);

-- =====================================================
-- PART 6: CLASS JOIN REQUESTS TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS public.class_join_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  class_id UUID NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  requester_name TEXT NOT NULL, -- Name entered when requesting
  requester_email TEXT NOT NULL, -- Email from user profile
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
  rejection_reason TEXT,
  requested_at TIMESTAMPTZ DEFAULT NOW(),
  processed_at TIMESTAMPTZ,
  processed_by UUID REFERENCES auth.users(id), -- Who approved/rejected
  UNIQUE(class_id, user_id, status) -- Prevent duplicate pending requests
);

CREATE INDEX IF NOT EXISTS idx_join_requests_class ON public.class_join_requests(class_id);
CREATE INDEX IF NOT EXISTS idx_join_requests_user ON public.class_join_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_join_requests_status ON public.class_join_requests(class_id, status);
CREATE INDEX IF NOT EXISTS idx_join_requests_pending ON public.class_join_requests(class_id) WHERE status = 'pending';

-- =====================================================
-- PART 7: CLASS CHATROOMS TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS public.class_chatrooms (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  class_id UUID NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE UNIQUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_class_chatrooms_class ON public.class_chatrooms(class_id);

-- =====================================================
-- PART 8: CLASS MESSAGES TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS public.class_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chatroom_id UUID NOT NULL REFERENCES public.class_chatrooms(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  message TEXT,
  media_url TEXT, -- For images/videos
  file_url TEXT, -- For other files
  file_name TEXT,
  file_type TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_class_messages_chatroom ON public.class_messages(chatroom_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_class_messages_user ON public.class_messages(user_id);

-- =====================================================
-- PART 9: USER HIDDEN UNITS TABLE
-- (For when users individually delete units from their view)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.user_hidden_units (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  unit_id UUID NOT NULL REFERENCES public.class_units(id) ON DELETE CASCADE,
  hidden_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, unit_id)
);

CREATE INDEX IF NOT EXISTS idx_user_hidden_units_user ON public.user_hidden_units(user_id);
CREATE INDEX IF NOT EXISTS idx_user_hidden_units_unit ON public.user_hidden_units(unit_id);

-- =====================================================
-- PART 10: UPDATE EXISTING TABLES FOR CLASS SYSTEM
-- =====================================================

-- Update units table to reference class_units instead of classes
ALTER TABLE public.units 
ADD COLUMN IF NOT EXISTS class_unit_id UUID REFERENCES public.class_units(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_units_class_unit ON public.units(class_unit_id);

-- Update uploads to be class-specific
ALTER TABLE public.uploads
ADD COLUMN IF NOT EXISTS class_id UUID REFERENCES public.classes(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_uploads_class ON public.uploads(class_id);

-- =====================================================
-- PART 11: ROW LEVEL SECURITY POLICIES
-- =====================================================

-- Enable RLS on all new tables
ALTER TABLE public.countries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.universities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.courses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.classes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.class_units ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.class_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.class_join_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.class_chatrooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.class_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_hidden_units ENABLE ROW LEVEL SECURITY;

-- Countries Policies
DROP POLICY IF EXISTS "Countries are viewable by everyone" ON public.countries;
CREATE POLICY "Countries are viewable by everyone" ON public.countries
  FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS "Only admins can manage countries" ON public.countries;
CREATE POLICY "Only admins can manage countries" ON public.countries
  FOR ALL TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE profiles.user_id = auth.uid() 
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Universities Policies
DROP POLICY IF EXISTS "Universities are viewable by everyone" ON public.universities;
CREATE POLICY "Universities are viewable by everyone" ON public.universities
  FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS "Only admins can manage universities" ON public.universities;
CREATE POLICY "Only admins can manage universities" ON public.universities
  FOR ALL TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE profiles.user_id = auth.uid() 
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Courses Policies
DROP POLICY IF EXISTS "Courses are viewable by everyone" ON public.courses;
CREATE POLICY "Courses are viewable by everyone" ON public.courses
  FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS "Only admins can manage courses" ON public.courses;
CREATE POLICY "Only admins can manage courses" ON public.courses
  FOR ALL TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE profiles.user_id = auth.uid() 
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Classes Policies
DROP POLICY IF EXISTS "Anyone can view searchable classes" ON public.classes;
CREATE POLICY "Anyone can view searchable classes" ON public.classes
  FOR SELECT TO authenticated USING (
    is_searchable = true 
    OR creator_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = classes.id 
      AND class_members.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Authenticated users can create classes" ON public.classes;
CREATE POLICY "Authenticated users can create classes" ON public.classes
  FOR INSERT TO authenticated WITH CHECK (creator_id = auth.uid());

DROP POLICY IF EXISTS "Class creators can update their classes" ON public.classes;
CREATE POLICY "Class creators can update their classes" ON public.classes
  FOR UPDATE TO authenticated USING (
    creator_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = classes.id 
      AND class_members.user_id = auth.uid() 
      AND class_members.role = 'creator'
    )
  );

DROP POLICY IF EXISTS "Class creators can delete their classes" ON public.classes;
CREATE POLICY "Class creators can delete their classes" ON public.classes
  FOR DELETE TO authenticated USING (
    creator_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = classes.id 
      AND class_members.user_id = auth.uid() 
      AND class_members.role = 'creator'
    )
  );

-- Class Units Policies
DROP POLICY IF EXISTS "Class members can view units" ON public.class_units;
CREATE POLICY "Class members can view units" ON public.class_units
  FOR SELECT TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = class_units.class_id 
      AND class_members.user_id = auth.uid()
    )
    AND NOT EXISTS (
      SELECT 1 FROM public.user_hidden_units
      WHERE user_hidden_units.unit_id = class_units.id
      AND user_hidden_units.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Class creators can manage units" ON public.class_units;
CREATE POLICY "Class creators can manage units" ON public.class_units
  FOR ALL TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = class_units.class_id 
      AND class_members.user_id = auth.uid() 
      AND class_members.role = 'creator'
    )
  );

-- Class Members Policies
DROP POLICY IF EXISTS "Class members can view other members" ON public.class_members;
CREATE POLICY "Class members can view other members" ON public.class_members
  FOR SELECT TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.class_members cm 
      WHERE cm.class_id = class_members.class_id 
      AND cm.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Class creators can manage members" ON public.class_members;
CREATE POLICY "Class creators can manage members" ON public.class_members
  FOR ALL TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = class_members.class_id 
      AND class_members.user_id = auth.uid() 
      AND class_members.role = 'creator'
    )
    OR user_id = auth.uid() -- Users can leave (delete their own membership)
  );

-- Join Requests Policies
DROP POLICY IF EXISTS "Users can view their own requests" ON public.class_join_requests;
CREATE POLICY "Users can view their own requests" ON public.class_join_requests
  FOR SELECT TO authenticated USING (
    user_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = class_join_requests.class_id 
      AND class_members.user_id = auth.uid() 
      AND class_members.role = 'creator'
    )
  );

DROP POLICY IF EXISTS "Users can create join requests" ON public.class_join_requests;
CREATE POLICY "Users can create join requests" ON public.class_join_requests
  FOR INSERT TO authenticated WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS "Class creators can update requests" ON public.class_join_requests;
CREATE POLICY "Class creators can update requests" ON public.class_join_requests
  FOR UPDATE TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = class_join_requests.class_id 
      AND class_members.user_id = auth.uid() 
      AND class_members.role = 'creator'
    )
  );

-- Class Chatrooms Policies
DROP POLICY IF EXISTS "Class members can view chatroom" ON public.class_chatrooms;
CREATE POLICY "Class members can view chatroom" ON public.class_chatrooms
  FOR SELECT TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = class_chatrooms.class_id 
      AND class_members.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Class creators can create chatroom" ON public.class_chatrooms;
CREATE POLICY "Class creators can create chatroom" ON public.class_chatrooms
  FOR INSERT TO authenticated WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.class_members 
      WHERE class_members.class_id = class_chatrooms.class_id 
      AND class_members.user_id = auth.uid() 
      AND class_members.role = 'creator'
    )
  );

-- Class Messages Policies
DROP POLICY IF EXISTS "Class members can view messages" ON public.class_messages;
CREATE POLICY "Class members can view messages" ON public.class_messages
  FOR SELECT TO authenticated USING (
    EXISTS (
      SELECT 1 FROM public.class_chatrooms
      JOIN public.class_members ON class_members.class_id = class_chatrooms.class_id
      WHERE class_chatrooms.id = class_messages.chatroom_id 
      AND class_members.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Class members can send messages" ON public.class_messages;
CREATE POLICY "Class members can send messages" ON public.class_messages
  FOR INSERT TO authenticated WITH CHECK (
    user_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.class_chatrooms
      JOIN public.class_members ON class_members.class_id = class_chatrooms.class_id
      WHERE class_chatrooms.id = class_messages.chatroom_id 
      AND class_members.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Users can update their own messages" ON public.class_messages;
CREATE POLICY "Users can update their own messages" ON public.class_messages
  FOR UPDATE TO authenticated USING (user_id = auth.uid());

DROP POLICY IF EXISTS "Users can delete their own messages" ON public.class_messages;
CREATE POLICY "Users can delete their own messages" ON public.class_messages
  FOR DELETE TO authenticated USING (user_id = auth.uid());

-- User Hidden Units Policies
DROP POLICY IF EXISTS "Users can manage their hidden units" ON public.user_hidden_units;
CREATE POLICY "Users can manage their hidden units" ON public.user_hidden_units
  FOR ALL TO authenticated USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- =====================================================
-- PART 12: HELPER FUNCTIONS
-- =====================================================

-- Function to generate unique share code for classes
CREATE OR REPLACE FUNCTION generate_class_share_code()
RETURNS TEXT AS $$
DECLARE
  chars TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; -- Excluding similar chars
  result TEXT := '';
  i INTEGER;
  is_unique BOOLEAN := FALSE;
BEGIN
  WHILE NOT is_unique LOOP
    result := '';
    FOR i IN 1..8 LOOP
      result := result || substr(chars, floor(random() * length(chars) + 1)::int, 1);
    END LOOP;
    
    -- Check if code already exists
    IF NOT EXISTS (SELECT 1 FROM public.classes WHERE share_code = result) THEN
      is_unique := TRUE;
    END IF;
  END LOOP;
  
  RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to set share_code on class creation if not provided
CREATE OR REPLACE FUNCTION set_class_share_code()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.share_code IS NULL OR NEW.share_code = '' THEN
    NEW.share_code := generate_class_share_code();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_set_share_code ON public.classes;
CREATE TRIGGER trigger_set_share_code
  BEFORE INSERT ON public.classes
  FOR EACH ROW
  EXECUTE FUNCTION set_class_share_code();

-- Function to automatically create chatroom when class is created
CREATE OR REPLACE FUNCTION create_class_chatroom()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.class_chatrooms (class_id)
  VALUES (NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_create_chatroom ON public.classes;
CREATE TRIGGER trigger_create_chatroom
  AFTER INSERT ON public.classes
  FOR EACH ROW
  EXECUTE FUNCTION create_class_chatroom();

-- Function to automatically add creator as member with 'creator' role
CREATE OR REPLACE FUNCTION add_creator_as_member()
RETURNS TRIGGER AS $$
BEGIN
  -- Only add if creator_id is not null
  IF NEW.creator_id IS NOT NULL THEN
    INSERT INTO public.class_members (class_id, user_id, role)
    VALUES (NEW.id, NEW.creator_id, 'creator')
    ON CONFLICT (class_id, user_id) DO NOTHING;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_add_creator ON public.classes;
CREATE TRIGGER trigger_add_creator
  AFTER INSERT ON public.classes
  FOR EACH ROW
  EXECUTE FUNCTION add_creator_as_member();

-- Function to handle class creator transfer/deletion cascade
CREATE OR REPLACE FUNCTION handle_class_creator_leave()
RETURNS TRIGGER AS $$
DECLARE
  next_member UUID;
BEGIN
  -- If the leaving member is the creator
  IF OLD.role = 'creator' THEN
    -- Find the next oldest member
    SELECT user_id INTO next_member
    FROM public.class_members
    WHERE class_id = OLD.class_id
      AND user_id != OLD.user_id
    ORDER BY joined_at ASC
    LIMIT 1;
    
    -- If there's another member, transfer creator role
    IF next_member IS NOT NULL THEN
      UPDATE public.class_members
      SET role = 'creator'
      WHERE class_id = OLD.class_id 
        AND user_id = next_member;
      
      UPDATE public.classes
      SET creator_id = next_member
      WHERE id = OLD.class_id;
    ELSE
      -- No other members, delete the class
      DELETE FROM public.classes WHERE id = OLD.class_id;
    END IF;
  END IF;
  
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_handle_creator_leave ON public.class_members;
CREATE TRIGGER trigger_handle_creator_leave
  BEFORE DELETE ON public.class_members
  FOR EACH ROW
  EXECUTE FUNCTION handle_class_creator_leave();

-- Function to approve join request and add member
CREATE OR REPLACE FUNCTION approve_join_request(
  p_request_id UUID,
  p_approver_id UUID
)
RETURNS BOOLEAN AS $$
DECLARE
  v_class_id UUID;
  v_user_id UUID;
BEGIN
  -- Get request details
  SELECT class_id, user_id INTO v_class_id, v_user_id
  FROM public.class_join_requests
  WHERE id = p_request_id AND status = 'pending';
  
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;
  
  -- Update request status
  UPDATE public.class_join_requests
  SET status = 'approved',
      processed_at = NOW(),
      processed_by = p_approver_id
  WHERE id = p_request_id;
  
  -- Add user as member
  INSERT INTO public.class_members (class_id, user_id, role)
  VALUES (v_class_id, v_user_id, 'member')
  ON CONFLICT (class_id, user_id) DO NOTHING;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to reject join request
CREATE OR REPLACE FUNCTION reject_join_request(
  p_request_id UUID,
  p_approver_id UUID,
  p_reason TEXT DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
  UPDATE public.class_join_requests
  SET status = 'rejected',
      processed_at = NOW(),
      processed_by = p_approver_id,
      rejection_reason = p_reason
  WHERE id = p_request_id AND status = 'pending';
  
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to transfer class creator role
CREATE OR REPLACE FUNCTION transfer_class_creator(
  p_class_id UUID,
  p_current_creator_id UUID,
  p_new_creator_email TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
  v_new_creator_id UUID;
BEGIN
  -- Find the new creator by email
  SELECT user_id INTO v_new_creator_id
  FROM public.profiles
  WHERE email = p_new_creator_email;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'User with email % not found', p_new_creator_email;
  END IF;
  
  -- Verify new creator is a member
  IF NOT EXISTS (
    SELECT 1 FROM public.class_members
    WHERE class_id = p_class_id AND user_id = v_new_creator_id
  ) THEN
    RAISE EXCEPTION 'User is not a member of this class';
  END IF;
  
  -- Update the class
  UPDATE public.classes
  SET creator_id = v_new_creator_id
  WHERE id = p_class_id AND creator_id = p_current_creator_id;
  
  -- Update member roles
  UPDATE public.class_members
  SET role = 'member'
  WHERE class_id = p_class_id AND user_id = p_current_creator_id;
  
  UPDATE public.class_members
  SET role = 'creator'
  WHERE class_id = p_class_id AND user_id = v_new_creator_id;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- SUCCESS MESSAGE
-- =====================================================

DO $$
BEGIN
  RAISE NOTICE 'âœ… New Class System database schema created successfully!';
  RAISE NOTICE 'ðŸ“‹ Created tables: countries, universities, courses, classes, class_units, class_members, class_join_requests, class_chatrooms, class_messages, user_hidden_units';
  RAISE NOTICE 'ðŸ”’ RLS policies enabled on all tables';
  RAISE NOTICE 'âš¡ Helper functions created for automation';
  RAISE NOTICE 'ðŸš€ Ready for Phase 2: Migration of existing data';
END $$;

